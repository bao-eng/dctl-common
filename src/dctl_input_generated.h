// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_DCTLINPUT_DCTL_FLAT_INPUT_H_
#define FLATBUFFERS_GENERATED_DCTLINPUT_DCTL_FLAT_INPUT_H_

#include "flatbuffers/flatbuffers.h"

namespace dctl {
namespace flat_input {

struct Input;

struct InputPack;
struct InputPackBuilder;

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Input FLATBUFFERS_FINAL_CLASS {
 private:
  uint32_t sequence_;
  uint8_t left_;
  uint8_t right_;
  uint8_t up_;
  uint8_t down_;

 public:
  Input()
      : sequence_(0),
        left_(0),
        right_(0),
        up_(0),
        down_(0) {
  }
  Input(uint32_t _sequence, bool _left, bool _right, bool _up, bool _down)
      : sequence_(flatbuffers::EndianScalar(_sequence)),
        left_(flatbuffers::EndianScalar(static_cast<uint8_t>(_left))),
        right_(flatbuffers::EndianScalar(static_cast<uint8_t>(_right))),
        up_(flatbuffers::EndianScalar(static_cast<uint8_t>(_up))),
        down_(flatbuffers::EndianScalar(static_cast<uint8_t>(_down))) {
  }
  uint32_t sequence() const {
    return flatbuffers::EndianScalar(sequence_);
  }
  bool left() const {
    return flatbuffers::EndianScalar(left_) != 0;
  }
  bool right() const {
    return flatbuffers::EndianScalar(right_) != 0;
  }
  bool up() const {
    return flatbuffers::EndianScalar(up_) != 0;
  }
  bool down() const {
    return flatbuffers::EndianScalar(down_) != 0;
  }
};
FLATBUFFERS_STRUCT_END(Input, 8);

struct InputPack FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef InputPackBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PLAYER_ID = 4,
    VT_INPUTS = 6
  };
  uint32_t player_id() const {
    return GetField<uint32_t>(VT_PLAYER_ID, 0);
  }
  const flatbuffers::Vector<const dctl::flat_input::Input *> *inputs() const {
    return GetPointer<const flatbuffers::Vector<const dctl::flat_input::Input *> *>(VT_INPUTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_PLAYER_ID) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           verifier.EndTable();
  }
};

struct InputPackBuilder {
  typedef InputPack Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_player_id(uint32_t player_id) {
    fbb_.AddElement<uint32_t>(InputPack::VT_PLAYER_ID, player_id, 0);
  }
  void add_inputs(flatbuffers::Offset<flatbuffers::Vector<const dctl::flat_input::Input *>> inputs) {
    fbb_.AddOffset(InputPack::VT_INPUTS, inputs);
  }
  explicit InputPackBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<InputPack> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<InputPack>(end);
    return o;
  }
};

inline flatbuffers::Offset<InputPack> CreateInputPack(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t player_id = 0,
    flatbuffers::Offset<flatbuffers::Vector<const dctl::flat_input::Input *>> inputs = 0) {
  InputPackBuilder builder_(_fbb);
  builder_.add_inputs(inputs);
  builder_.add_player_id(player_id);
  return builder_.Finish();
}

inline flatbuffers::Offset<InputPack> CreateInputPackDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t player_id = 0,
    const std::vector<dctl::flat_input::Input> *inputs = nullptr) {
  auto inputs__ = inputs ? _fbb.CreateVectorOfStructs<dctl::flat_input::Input>(*inputs) : 0;
  return dctl::flat_input::CreateInputPack(
      _fbb,
      player_id,
      inputs__);
}

inline const dctl::flat_input::InputPack *GetInputPack(const void *buf) {
  return flatbuffers::GetRoot<dctl::flat_input::InputPack>(buf);
}

inline const dctl::flat_input::InputPack *GetSizePrefixedInputPack(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<dctl::flat_input::InputPack>(buf);
}

inline const char *InputPackIdentifier() {
  return "INPP";
}

inline bool InputPackBufferHasIdentifier(const void *buf) {
  return flatbuffers::BufferHasIdentifier(
      buf, InputPackIdentifier());
}

inline bool VerifyInputPackBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<dctl::flat_input::InputPack>(InputPackIdentifier());
}

inline bool VerifySizePrefixedInputPackBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<dctl::flat_input::InputPack>(InputPackIdentifier());
}

inline const char *InputPackExtension() {
  return "inpp";
}

inline void FinishInputPackBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<dctl::flat_input::InputPack> root) {
  fbb.Finish(root, InputPackIdentifier());
}

inline void FinishSizePrefixedInputPackBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<dctl::flat_input::InputPack> root) {
  fbb.FinishSizePrefixed(root, InputPackIdentifier());
}

}  // namespace flat_input
}  // namespace dctl

#endif  // FLATBUFFERS_GENERATED_DCTLINPUT_DCTL_FLAT_INPUT_H_
