// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_DCTLMESSAGE_DCTL_FLAT_MSG_H_
#define FLATBUFFERS_GENERATED_DCTLMESSAGE_DCTL_FLAT_MSG_H_

#include "flatbuffers/flatbuffers.h"

namespace dctl {
namespace flat_msg {

struct Vec2;

struct Color;

struct Snake;
struct SnakeBuilder;

struct State;
struct StateBuilder;

struct Input;

struct InputPack;
struct InputPackBuilder;

struct Settings;

struct Request;
struct RequestBuilder;

struct Reply;
struct ReplyBuilder;

struct Message;
struct MessageBuilder;

enum Dir : int8_t {
  Dir_None = 0,
  Dir_Up = 1,
  Dir_Down = 2,
  Dir_Left = 3,
  Dir_Right = 4,
  Dir_MIN = Dir_None,
  Dir_MAX = Dir_Right
};

inline const Dir (&EnumValuesDir())[5] {
  static const Dir values[] = {
    Dir_None,
    Dir_Up,
    Dir_Down,
    Dir_Left,
    Dir_Right
  };
  return values;
}

inline const char * const *EnumNamesDir() {
  static const char * const names[6] = {
    "None",
    "Up",
    "Down",
    "Left",
    "Right",
    nullptr
  };
  return names;
}

inline const char *EnumNameDir(Dir e) {
  if (flatbuffers::IsOutRange(e, Dir_None, Dir_Right)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesDir()[index];
}

enum Any : uint8_t {
  Any_NONE = 0,
  Any_InputPack = 1,
  Any_State = 2,
  Any_Request = 3,
  Any_Reply = 4,
  Any_MIN = Any_NONE,
  Any_MAX = Any_Reply
};

inline const Any (&EnumValuesAny())[5] {
  static const Any values[] = {
    Any_NONE,
    Any_InputPack,
    Any_State,
    Any_Request,
    Any_Reply
  };
  return values;
}

inline const char * const *EnumNamesAny() {
  static const char * const names[6] = {
    "NONE",
    "InputPack",
    "State",
    "Request",
    "Reply",
    nullptr
  };
  return names;
}

inline const char *EnumNameAny(Any e) {
  if (flatbuffers::IsOutRange(e, Any_NONE, Any_Reply)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesAny()[index];
}

template<typename T> struct AnyTraits {
  static const Any enum_value = Any_NONE;
};

template<> struct AnyTraits<dctl::flat_msg::InputPack> {
  static const Any enum_value = Any_InputPack;
};

template<> struct AnyTraits<dctl::flat_msg::State> {
  static const Any enum_value = Any_State;
};

template<> struct AnyTraits<dctl::flat_msg::Request> {
  static const Any enum_value = Any_Request;
};

template<> struct AnyTraits<dctl::flat_msg::Reply> {
  static const Any enum_value = Any_Reply;
};

bool VerifyAny(flatbuffers::Verifier &verifier, const void *obj, Any type);
bool VerifyAnyVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Vec2 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;

 public:
  Vec2()
      : x_(0),
        y_(0) {
  }
  Vec2(float _x, float _y)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
};
FLATBUFFERS_STRUCT_END(Vec2, 8);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(1) Color FLATBUFFERS_FINAL_CLASS {
 private:
  uint8_t r_;
  uint8_t g_;
  uint8_t b_;

 public:
  Color()
      : r_(0),
        g_(0),
        b_(0) {
  }
  Color(uint8_t _r, uint8_t _g, uint8_t _b)
      : r_(flatbuffers::EndianScalar(_r)),
        g_(flatbuffers::EndianScalar(_g)),
        b_(flatbuffers::EndianScalar(_b)) {
  }
  uint8_t r() const {
    return flatbuffers::EndianScalar(r_);
  }
  uint8_t g() const {
    return flatbuffers::EndianScalar(g_);
  }
  uint8_t b() const {
    return flatbuffers::EndianScalar(b_);
  }
};
FLATBUFFERS_STRUCT_END(Color, 3);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Input FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t sequence_;
  int32_t player_id_;
  uint8_t left_;
  uint8_t right_;
  uint8_t up_;
  uint8_t down_;

 public:
  Input()
      : sequence_(0),
        player_id_(0),
        left_(0),
        right_(0),
        up_(0),
        down_(0) {
  }
  Input(int32_t _sequence, int32_t _player_id, bool _left, bool _right, bool _up, bool _down)
      : sequence_(flatbuffers::EndianScalar(_sequence)),
        player_id_(flatbuffers::EndianScalar(_player_id)),
        left_(flatbuffers::EndianScalar(static_cast<uint8_t>(_left))),
        right_(flatbuffers::EndianScalar(static_cast<uint8_t>(_right))),
        up_(flatbuffers::EndianScalar(static_cast<uint8_t>(_up))),
        down_(flatbuffers::EndianScalar(static_cast<uint8_t>(_down))) {
  }
  int32_t sequence() const {
    return flatbuffers::EndianScalar(sequence_);
  }
  int32_t player_id() const {
    return flatbuffers::EndianScalar(player_id_);
  }
  bool left() const {
    return flatbuffers::EndianScalar(left_) != 0;
  }
  bool right() const {
    return flatbuffers::EndianScalar(right_) != 0;
  }
  bool up() const {
    return flatbuffers::EndianScalar(up_) != 0;
  }
  bool down() const {
    return flatbuffers::EndianScalar(down_) != 0;
  }
};
FLATBUFFERS_STRUCT_END(Input, 12);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) Settings FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t max_clients_;
  float map_width_;
  float map_height_;
  float speed_;
  double dt_;
  int32_t max_length_;
  float head_diameter_;
  float tail_width_;
  int32_t padding0__;

 public:
  Settings()
      : max_clients_(0),
        map_width_(0),
        map_height_(0),
        speed_(0),
        dt_(0),
        max_length_(0),
        head_diameter_(0),
        tail_width_(0),
        padding0__(0) {
    (void)padding0__;
  }
  Settings(int32_t _max_clients, float _map_width, float _map_height, float _speed, double _dt, int32_t _max_length, float _head_diameter, float _tail_width)
      : max_clients_(flatbuffers::EndianScalar(_max_clients)),
        map_width_(flatbuffers::EndianScalar(_map_width)),
        map_height_(flatbuffers::EndianScalar(_map_height)),
        speed_(flatbuffers::EndianScalar(_speed)),
        dt_(flatbuffers::EndianScalar(_dt)),
        max_length_(flatbuffers::EndianScalar(_max_length)),
        head_diameter_(flatbuffers::EndianScalar(_head_diameter)),
        tail_width_(flatbuffers::EndianScalar(_tail_width)),
        padding0__(0) {
    (void)padding0__;
  }
  int32_t max_clients() const {
    return flatbuffers::EndianScalar(max_clients_);
  }
  float map_width() const {
    return flatbuffers::EndianScalar(map_width_);
  }
  float map_height() const {
    return flatbuffers::EndianScalar(map_height_);
  }
  float speed() const {
    return flatbuffers::EndianScalar(speed_);
  }
  double dt() const {
    return flatbuffers::EndianScalar(dt_);
  }
  int32_t max_length() const {
    return flatbuffers::EndianScalar(max_length_);
  }
  float head_diameter() const {
    return flatbuffers::EndianScalar(head_diameter_);
  }
  float tail_width() const {
    return flatbuffers::EndianScalar(tail_width_);
  }
};
FLATBUFFERS_STRUCT_END(Settings, 40);

struct Snake FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SnakeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PLAYER_ID = 4,
    VT_TAIL = 6,
    VT_DIR = 8,
    VT_COLOR = 10
  };
  int32_t player_id() const {
    return GetField<int32_t>(VT_PLAYER_ID, 0);
  }
  const flatbuffers::Vector<const dctl::flat_msg::Vec2 *> *tail() const {
    return GetPointer<const flatbuffers::Vector<const dctl::flat_msg::Vec2 *> *>(VT_TAIL);
  }
  dctl::flat_msg::Dir dir() const {
    return static_cast<dctl::flat_msg::Dir>(GetField<int8_t>(VT_DIR, 0));
  }
  const dctl::flat_msg::Color *color() const {
    return GetStruct<const dctl::flat_msg::Color *>(VT_COLOR);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_PLAYER_ID) &&
           VerifyOffset(verifier, VT_TAIL) &&
           verifier.VerifyVector(tail()) &&
           VerifyField<int8_t>(verifier, VT_DIR) &&
           VerifyField<dctl::flat_msg::Color>(verifier, VT_COLOR) &&
           verifier.EndTable();
  }
};

struct SnakeBuilder {
  typedef Snake Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_player_id(int32_t player_id) {
    fbb_.AddElement<int32_t>(Snake::VT_PLAYER_ID, player_id, 0);
  }
  void add_tail(flatbuffers::Offset<flatbuffers::Vector<const dctl::flat_msg::Vec2 *>> tail) {
    fbb_.AddOffset(Snake::VT_TAIL, tail);
  }
  void add_dir(dctl::flat_msg::Dir dir) {
    fbb_.AddElement<int8_t>(Snake::VT_DIR, static_cast<int8_t>(dir), 0);
  }
  void add_color(const dctl::flat_msg::Color *color) {
    fbb_.AddStruct(Snake::VT_COLOR, color);
  }
  explicit SnakeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Snake> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Snake>(end);
    return o;
  }
};

inline flatbuffers::Offset<Snake> CreateSnake(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t player_id = 0,
    flatbuffers::Offset<flatbuffers::Vector<const dctl::flat_msg::Vec2 *>> tail = 0,
    dctl::flat_msg::Dir dir = dctl::flat_msg::Dir_None,
    const dctl::flat_msg::Color *color = 0) {
  SnakeBuilder builder_(_fbb);
  builder_.add_color(color);
  builder_.add_tail(tail);
  builder_.add_player_id(player_id);
  builder_.add_dir(dir);
  return builder_.Finish();
}

inline flatbuffers::Offset<Snake> CreateSnakeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t player_id = 0,
    const std::vector<dctl::flat_msg::Vec2> *tail = nullptr,
    dctl::flat_msg::Dir dir = dctl::flat_msg::Dir_None,
    const dctl::flat_msg::Color *color = 0) {
  auto tail__ = tail ? _fbb.CreateVectorOfStructs<dctl::flat_msg::Vec2>(*tail) : 0;
  return dctl::flat_msg::CreateSnake(
      _fbb,
      player_id,
      tail__,
      dir,
      color);
}

struct State FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StateBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SEQUENCE = 4,
    VT_SNAKES = 6
  };
  int32_t sequence() const {
    return GetField<int32_t>(VT_SEQUENCE, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<dctl::flat_msg::Snake>> *snakes() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<dctl::flat_msg::Snake>> *>(VT_SNAKES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_SEQUENCE) &&
           VerifyOffset(verifier, VT_SNAKES) &&
           verifier.VerifyVector(snakes()) &&
           verifier.VerifyVectorOfTables(snakes()) &&
           verifier.EndTable();
  }
};

struct StateBuilder {
  typedef State Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_sequence(int32_t sequence) {
    fbb_.AddElement<int32_t>(State::VT_SEQUENCE, sequence, 0);
  }
  void add_snakes(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<dctl::flat_msg::Snake>>> snakes) {
    fbb_.AddOffset(State::VT_SNAKES, snakes);
  }
  explicit StateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<State> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<State>(end);
    return o;
  }
};

inline flatbuffers::Offset<State> CreateState(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t sequence = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<dctl::flat_msg::Snake>>> snakes = 0) {
  StateBuilder builder_(_fbb);
  builder_.add_snakes(snakes);
  builder_.add_sequence(sequence);
  return builder_.Finish();
}

inline flatbuffers::Offset<State> CreateStateDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t sequence = 0,
    const std::vector<flatbuffers::Offset<dctl::flat_msg::Snake>> *snakes = nullptr) {
  auto snakes__ = snakes ? _fbb.CreateVector<flatbuffers::Offset<dctl::flat_msg::Snake>>(*snakes) : 0;
  return dctl::flat_msg::CreateState(
      _fbb,
      sequence,
      snakes__);
}

struct InputPack FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef InputPackBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INPUTS = 4
  };
  const flatbuffers::Vector<const dctl::flat_msg::Input *> *inputs() const {
    return GetPointer<const flatbuffers::Vector<const dctl::flat_msg::Input *> *>(VT_INPUTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           verifier.EndTable();
  }
};

struct InputPackBuilder {
  typedef InputPack Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_inputs(flatbuffers::Offset<flatbuffers::Vector<const dctl::flat_msg::Input *>> inputs) {
    fbb_.AddOffset(InputPack::VT_INPUTS, inputs);
  }
  explicit InputPackBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<InputPack> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<InputPack>(end);
    return o;
  }
};

inline flatbuffers::Offset<InputPack> CreateInputPack(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<const dctl::flat_msg::Input *>> inputs = 0) {
  InputPackBuilder builder_(_fbb);
  builder_.add_inputs(inputs);
  return builder_.Finish();
}

inline flatbuffers::Offset<InputPack> CreateInputPackDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<dctl::flat_msg::Input> *inputs = nullptr) {
  auto inputs__ = inputs ? _fbb.CreateVectorOfStructs<dctl::flat_msg::Input>(*inputs) : 0;
  return dctl::flat_msg::CreateInputPack(
      _fbb,
      inputs__);
}

struct Request FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           verifier.EndTable();
  }
};

struct RequestBuilder {
  typedef Request Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Request::VT_NAME, name);
  }
  explicit RequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Request> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Request>(end);
    return o;
  }
};

inline flatbuffers::Offset<Request> CreateRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0) {
  RequestBuilder builder_(_fbb);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<Request> CreateRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return dctl::flat_msg::CreateRequest(
      _fbb,
      name__);
}

struct Reply FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ReplyBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PLAYER_ID = 4,
    VT_SETTINGS = 6
  };
  int32_t player_id() const {
    return GetField<int32_t>(VT_PLAYER_ID, 0);
  }
  const dctl::flat_msg::Settings *settings() const {
    return GetStruct<const dctl::flat_msg::Settings *>(VT_SETTINGS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_PLAYER_ID) &&
           VerifyField<dctl::flat_msg::Settings>(verifier, VT_SETTINGS) &&
           verifier.EndTable();
  }
};

struct ReplyBuilder {
  typedef Reply Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_player_id(int32_t player_id) {
    fbb_.AddElement<int32_t>(Reply::VT_PLAYER_ID, player_id, 0);
  }
  void add_settings(const dctl::flat_msg::Settings *settings) {
    fbb_.AddStruct(Reply::VT_SETTINGS, settings);
  }
  explicit ReplyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Reply> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Reply>(end);
    return o;
  }
};

inline flatbuffers::Offset<Reply> CreateReply(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t player_id = 0,
    const dctl::flat_msg::Settings *settings = 0) {
  ReplyBuilder builder_(_fbb);
  builder_.add_settings(settings);
  builder_.add_player_id(player_id);
  return builder_.Finish();
}

struct Message FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MSG_TYPE = 4,
    VT_MSG = 6
  };
  dctl::flat_msg::Any msg_type() const {
    return static_cast<dctl::flat_msg::Any>(GetField<uint8_t>(VT_MSG_TYPE, 0));
  }
  const void *msg() const {
    return GetPointer<const void *>(VT_MSG);
  }
  template<typename T> const T *msg_as() const;
  const dctl::flat_msg::InputPack *msg_as_InputPack() const {
    return msg_type() == dctl::flat_msg::Any_InputPack ? static_cast<const dctl::flat_msg::InputPack *>(msg()) : nullptr;
  }
  const dctl::flat_msg::State *msg_as_State() const {
    return msg_type() == dctl::flat_msg::Any_State ? static_cast<const dctl::flat_msg::State *>(msg()) : nullptr;
  }
  const dctl::flat_msg::Request *msg_as_Request() const {
    return msg_type() == dctl::flat_msg::Any_Request ? static_cast<const dctl::flat_msg::Request *>(msg()) : nullptr;
  }
  const dctl::flat_msg::Reply *msg_as_Reply() const {
    return msg_type() == dctl::flat_msg::Any_Reply ? static_cast<const dctl::flat_msg::Reply *>(msg()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_MSG_TYPE) &&
           VerifyOffset(verifier, VT_MSG) &&
           VerifyAny(verifier, msg(), msg_type()) &&
           verifier.EndTable();
  }
};

template<> inline const dctl::flat_msg::InputPack *Message::msg_as<dctl::flat_msg::InputPack>() const {
  return msg_as_InputPack();
}

template<> inline const dctl::flat_msg::State *Message::msg_as<dctl::flat_msg::State>() const {
  return msg_as_State();
}

template<> inline const dctl::flat_msg::Request *Message::msg_as<dctl::flat_msg::Request>() const {
  return msg_as_Request();
}

template<> inline const dctl::flat_msg::Reply *Message::msg_as<dctl::flat_msg::Reply>() const {
  return msg_as_Reply();
}

struct MessageBuilder {
  typedef Message Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_msg_type(dctl::flat_msg::Any msg_type) {
    fbb_.AddElement<uint8_t>(Message::VT_MSG_TYPE, static_cast<uint8_t>(msg_type), 0);
  }
  void add_msg(flatbuffers::Offset<void> msg) {
    fbb_.AddOffset(Message::VT_MSG, msg);
  }
  explicit MessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Message> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Message>(end);
    return o;
  }
};

inline flatbuffers::Offset<Message> CreateMessage(
    flatbuffers::FlatBufferBuilder &_fbb,
    dctl::flat_msg::Any msg_type = dctl::flat_msg::Any_NONE,
    flatbuffers::Offset<void> msg = 0) {
  MessageBuilder builder_(_fbb);
  builder_.add_msg(msg);
  builder_.add_msg_type(msg_type);
  return builder_.Finish();
}

inline bool VerifyAny(flatbuffers::Verifier &verifier, const void *obj, Any type) {
  switch (type) {
    case Any_NONE: {
      return true;
    }
    case Any_InputPack: {
      auto ptr = reinterpret_cast<const dctl::flat_msg::InputPack *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Any_State: {
      auto ptr = reinterpret_cast<const dctl::flat_msg::State *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Any_Request: {
      auto ptr = reinterpret_cast<const dctl::flat_msg::Request *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Any_Reply: {
      auto ptr = reinterpret_cast<const dctl::flat_msg::Reply *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyAnyVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyAny(
        verifier,  values->Get(i), types->GetEnum<Any>(i))) {
      return false;
    }
  }
  return true;
}

inline const dctl::flat_msg::Message *GetMessage(const void *buf) {
  return flatbuffers::GetRoot<dctl::flat_msg::Message>(buf);
}

inline const dctl::flat_msg::Message *GetSizePrefixedMessage(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<dctl::flat_msg::Message>(buf);
}

inline const char *MessageIdentifier() {
  return "MSG_";
}

inline bool MessageBufferHasIdentifier(const void *buf) {
  return flatbuffers::BufferHasIdentifier(
      buf, MessageIdentifier());
}

inline bool VerifyMessageBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<dctl::flat_msg::Message>(MessageIdentifier());
}

inline bool VerifySizePrefixedMessageBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<dctl::flat_msg::Message>(MessageIdentifier());
}

inline const char *MessageExtension() {
  return "dctlmsg";
}

inline void FinishMessageBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<dctl::flat_msg::Message> root) {
  fbb.Finish(root, MessageIdentifier());
}

inline void FinishSizePrefixedMessageBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<dctl::flat_msg::Message> root) {
  fbb.FinishSizePrefixed(root, MessageIdentifier());
}

}  // namespace flat_msg
}  // namespace dctl

#endif  // FLATBUFFERS_GENERATED_DCTLMESSAGE_DCTL_FLAT_MSG_H_
